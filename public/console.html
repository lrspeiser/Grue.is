<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Grue Console</title>
  <style>
    body { background: #000; color: #0f0; font-family: 'Courier New', monospace; margin: 0; }
    #wrap { display: flex; height: 100vh; }
    #console { flex: 1; display: flex; flex-direction: column; }
    #log { flex: 1; padding: 16px; white-space: pre-wrap; overflow-y: auto; }
    #input { display: flex; border-top: 2px solid #060; }
    #cmd { flex: 1; padding: 12px; background: #020; color: #0f0; border: none; outline: none; font-family: inherit; font-size: 16px; }
    #send { padding: 12px 16px; background: #0f0; color: #020; border: none; font-weight: bold; cursor: pointer; }
    h2 { margin: 0 0 8px 0; color: #0f0; }
    #status { position: absolute; top: 8px; right: 16px; background: #020; border: 1px solid #060; padding: 6px 10px; color: #7f7; font-size: 12px; }
    .dim { color: #6f6; }
    .err { color: #f66; }
    .btn { background: #0f0; color: #020; border: none; padding: 8px 10px; cursor: pointer; font-weight: bold; margin-right: 8px; }
    .user { text-align: right; }
  </style>
</head>
<body>
  <div id="wrap">
    	<div id="console">
      	<div id="status" style="display:none"></div>
      	<div id="log"></div>
      	<div id="input">
        	<input id="cmd" placeholder="Type a command (e.g., 'look', 'go 1', 'go east', 'help')" />
        	<button id="send">Send</button>
        	<button id="restart" class="btn" style="margin-left:8px">Restart</button>
      	</div>
    	</div>
  </div>
  <script>
    const logEl = document.getElementById('log');
    const cmdEl = document.getElementById('cmd');
    const sendEl = document.getElementById('send');
    const statusEl = document.getElementById('status');
    const restartEl = document.getElementById('restart');

    let sessionId = null;
    let lastState = null;
    let pendingCommand = null;

    function append(text, cls, serverTs) {
      // Only show narrative and user messages in the on-screen console.
      // Debug/status/errors (cls present and not 'user') go to dev tools only.
      if (cls && cls !== 'user') {
        try { console.log(`[UI] ${new Date().toISOString()} ${text}`); } catch {}
        return;
      }
      const div = document.createElement('div');
      if (cls === 'user') div.className = 'user';
      div.textContent = text;
      logEl.appendChild(div);
      logEl.scrollTop = logEl.scrollHeight;
      try { console.log(`[UI] ${new Date().toISOString()} ${text}`); } catch {}
    }

    async function startSession() {
      append('Starting new session...', 'dim');
      cmdEl.disabled = true; sendEl.disabled = true;
      statusEl.style.display = 'block'; statusEl.textContent = 'Starting session...';

      // Streaming-only startup
      try {
        append('POST /v3/api/console/start-stream', 'dim');
        const resp = await fetch('/v3/api/console/start-stream', { method: 'POST' });
        const reader = resp.body.getReader();
        const decoder = new TextDecoder();
        let buf = '';
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          buf += decoder.decode(value, { stream: true });
          const parts = buf.split('\n\n');
          buf = parts.pop() || '';
          for (const p of parts) {
            if (!p.startsWith('data:')) continue;
            const json = p.slice(5).trim();
            try {
              const msg = JSON.parse(json);
              if (msg.type === 'debug') {
                if (msg.stage === 'start-stream' || msg.stage === 'command-stream') {
                  append(`LLM(${msg.stage}) model=${msg.model}`, 'dim', msg.ts);
                } else if (msg.stage === 'bg-json') {
                  append(`LLM(bg-json): ${msg.event}` + (msg.duration_ms ? ` duration=${msg.duration_ms}ms` : '') + (msg.model_duration_ms ? ` model=${msg.model_duration_ms}ms` : '') + (msg.error ? ` error=${msg.error}` : ''), 'dim', msg.ts);
                }
              }
              if (msg.type === 'session') {
                sessionId = msg.session_id;
                append(`[session ${msg.session_id}]`, 'dim', msg.ts);
              }
              if (msg.type === 'message') { append(msg.content); }
              if (msg.type === 'error') { append('Stream error: ' + msg.message, 'err'); }
            } catch {}
          }
        }
      } catch (e) {
        append('Stream failed: ' + e.message, 'err');
      }

      // Enable input after the narrative begins and session is known.
      statusEl.textContent = 'Ready';
      cmdEl.disabled = false; sendEl.disabled = false; cmdEl.focus();
      if (pendingCommand) { const c = pendingCommand; pendingCommand = null; append(c, 'user'); sendCommand(c); }
    }

    let isCommandInFlight = false;

    async function sendCommand(text) {
      if (!sessionId) {
        pendingCommand = text;
        append('Waiting for session to start before sending command...', 'dim');
        return;
      }
      if (isCommandInFlight) {
        pendingCommand = text;
        append('Command in progress; queuing your input...', 'dim');
        return;
      }
      isCommandInFlight = true;
      cmdEl.disabled = true; sendEl.disabled = true; statusEl.textContent = 'Sending command...';

      // Stream narrative for the command
      try {
        append('POST /v3/api/console/command-stream', 'dim');
        const resp = await fetch('/v3/api/console/command-stream', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ session_id: sessionId, command: text }) });
        const reader = resp.body.getReader();
        const decoder = new TextDecoder();
        let buf = '';
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          buf += decoder.decode(value, { stream: true });
          const parts = buf.split('\n\n');
          buf = parts.pop() || '';
          for (const p of parts) {
            if (!p.startsWith('data:')) continue;
            const json = p.slice(5).trim();
            try {
              const msg = JSON.parse(json);
              if (msg.type === 'message') append(msg.content, undefined, msg.ts);
              if (msg.type === 'error') append('Stream error: ' + msg.message, 'err', msg.ts);
            } catch {}
          }
        }
      } catch (e) {
        append('Stream failed: ' + e.message, 'err');
      }

      // Finalize UI state.
      isCommandInFlight = false;
      statusEl.textContent = 'Ready';
      cmdEl.disabled = false; sendEl.disabled = false; cmdEl.focus();
      if (pendingCommand) { const c = pendingCommand; pendingCommand = null; append(c, 'user'); sendCommand(c); }
    }

    sendEl.addEventListener('click', () => {
      const text = cmdEl.value.trim();
      if (!text) return;
      if (!sessionId) {
        pendingCommand = text;
        append('Waiting for session to start before sending command...', 'dim');
        cmdEl.value = '';
        return;
      }
      if (isCommandInFlight) {
        pendingCommand = text;
        append('Command in progress; queuing your input...', 'dim');
        cmdEl.value = '';
        return;
      }
      append(text, 'user');
      cmdEl.value = '';
      sendCommand(text);
    });

    restartEl.addEventListener('click', () => {
      sessionId = null; lastState = null; pendingCommand = null;
      append('Restarting session...', 'warning');
      startSession();
    });

    cmdEl.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') sendEl.click();
    });

    // Quick nano status ping on load
    (async () => {
      const t0 = performance.now();
      append('STATUS: sending nano warm check...', 'dim');
      try {
        const res = await fetch('/v3/api/console/status');
        const t1 = performance.now();
        const data = await res.json();
        if (res.ok && data.ok) {
          append(`STATUS: send=${new Date().toISOString()} recv=${new Date().toISOString()} elapsed_UI=${Math.round(t1 - t0)}ms server=${data.elapsed_ms}ms model=${data.model}`, 'dim');
        } else {
          append(`STATUS: failed server=${data.elapsed_ms}ms error=${data.error || res.status}`, 'err');
        }
      } catch (e) {
        const t1 = performance.now();
        append(`STATUS: failed after ${Math.round(t1 - t0)}ms: ${e.message}`, 'err');
      }
      startSession();
    })();
  </script>
</body>
</html>

