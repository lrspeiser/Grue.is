<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Grue Console</title>
  <style>
    body { background: #000; color: #0f0; font-family: 'Courier New', monospace; margin: 0; }
    #wrap { display: flex; height: 100vh; }
    #console { flex: 2; display: flex; flex-direction: column; }
    #log { flex: 1; padding: 16px; white-space: pre-wrap; overflow-y: auto; border-right: 2px solid #060; }
    #input { display: flex; border-top: 2px solid #060; }
    #cmd { flex: 1; padding: 12px; background: #020; color: #0f0; border: none; outline: none; font-family: inherit; font-size: 16px; }
    #send { padding: 12px 16px; background: #0f0; color: #020; border: none; font-weight: bold; cursor: pointer; }
    #sidebar { width: 360px; padding: 16px; background: #010; border-left: 2px solid #060; overflow-y: auto; }
    h2 { margin: 0 0 8px 0; color: #0f0; }
    #status { position: absolute; top: 8px; right: 380px; background: #020; border: 1px solid #060; padding: 6px 10px; color: #7f7; font-size: 12px; }
    .dim { color: #6f6; }
    .err { color: #f66; }
    .btn { background: #0f0; color: #020; border: none; padding: 8px 10px; cursor: pointer; font-weight: bold; margin-right: 8px; }
    .exit { margin: 4px 0; }
    .mono { font-family: 'Courier New', monospace; }
    .faint { color: #7f7; }
    .user { text-align: right; }
  </style>
</head>
<body>
  <div id="wrap">
    	<div id="console">
      	<div id="status" style="display:none"></div>
      	<div id="log"></div>
      	<div id="input">
        	<input id="cmd" placeholder="Type a command (e.g., 'look', 'go 1', 'go east', 'help')" />
        	<button id="send">Send</button>
        	<button id="restart" class="btn" style="margin-left:8px">Restart</button>
      	</div>
    	</div>
    <div id="sidebar">
      <h2>Room</h2>
      <div id="roomTitle" class="mono"></div>
      <div id="roomDesc" class="mono" style="margin-top:8px"></div>
      <h2 style="margin-top:16px">Exits</h2>
      <div id="exits"></div>
      <h2 style="margin-top:16px">Inventory</h2>
      <div id="inventory" class="mono faint">empty</div>
    </div>
  </div>
  <script>
    const logEl = document.getElementById('log');
    const cmdEl = document.getElementById('cmd');
    const sendEl = document.getElementById('send');
    const roomTitle = document.getElementById('roomTitle');
    const roomDesc = document.getElementById('roomDesc');
    const exitsEl = document.getElementById('exits');
    const inventoryEl = document.getElementById('inventory');
    const statusEl = document.getElementById('status');
    const restartEl = document.getElementById('restart');

    let sessionId = null;
    let lastState = null;
    let pendingCommand = null;
    let startController = null;
    let startedJsonFetch = false;
    let startJsonPromise = null;

    function append(text, cls, serverTs) {
      // Only show narrative and user messages in the on-screen console.
      // Debug/status/errors (cls present and not 'user') go to dev tools only.
      if (cls && cls !== 'user') {
        try { console.log(`[UI] ${new Date().toISOString()} ${text}`); } catch {}
        return;
      }
      const div = document.createElement('div');
      if (cls === 'user') div.className = 'user';
      div.textContent = text;
      logEl.appendChild(div);
      logEl.scrollTop = logEl.scrollHeight;
      try { console.log(`[UI] ${new Date().toISOString()} ${text}`); } catch {}
    }

    function renderState(state) {
      if (!state) return;
      const room = state.room;
      roomTitle.textContent = room?.title || '';
      roomDesc.textContent = room?.description || '';
      exitsEl.innerHTML = '';
      (room?.exits || []).forEach((ex, idx) => {
        const p = document.createElement('div');
        p.className = 'exit mono';
        p.textContent = `${idx+1}. ${ex.label}`;
        exitsEl.appendChild(p);
      });
      const inv = (state.inventory || []);
      inventoryEl.textContent = inv.length ? inv.map(i => i.name || i).join(', ') : 'empty';
    }

    async function startSession() {
      append('Starting new session...', 'dim');
      cmdEl.disabled = true; sendEl.disabled = true;
      statusEl.style.display = 'block'; statusEl.textContent = 'Starting session...';

      // 1) Stream narrative first (and kick JSON fetch as soon as we get session_id)
      let sessionFromStream = null;
      startedJsonFetch = false;
      startJsonPromise = null;
      try {
        append('POST /v3/api/console/start-stream', 'dim');
        const resp = await fetch('/v3/api/console/start-stream', { method: 'POST' });
        const reader = resp.body.getReader();
        const decoder = new TextDecoder();
        let buf = '';
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          buf += decoder.decode(value, { stream: true });
          const parts = buf.split('\n\n');
          buf = parts.pop() || '';
          for (const p of parts) {
            if (!p.startsWith('data:')) continue;
            const json = p.slice(5).trim();
            try {
              const msg = JSON.parse(json);
              if (msg.type === 'debug') {
                if (msg.stage === 'start-stream' || msg.stage === 'command-stream') {
                  append(`LLM(${msg.stage}) model=${msg.model}`, 'dim', msg.ts);
                } else if (msg.stage === 'bg-json') {
                  append(`LLM(bg-json): ${msg.event}` + (msg.duration_ms ? ` duration=${msg.duration_ms}ms` : '') + (msg.model_duration_ms ? ` model=${msg.model_duration_ms}ms` : '') + (msg.error ? ` error=${msg.error}` : ''), 'dim', msg.ts);
                }
              }
              if (msg.type === 'session') {
                sessionFromStream = msg.session_id;
                append(`[session ${msg.session_id}]`, 'dim', msg.ts);
                // Fire JSON state fetch immediately in parallel
                if (!startedJsonFetch) {
                  startedJsonFetch = true;
                  startJsonPromise = (async () => {
                    append('POST /v3/api/console/start (parallel)', 'dim');
                    const t0 = performance.now();
                    const res2 = await fetch('/v3/api/console/start', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ session_id: sessionFromStream }) });
                    const t1 = performance.now();
                    append(`Start(JSON parallel) ${res2.status} in ${Math.round(t1 - t0)}ms`, 'dim');
                    let data2;
                    try {
                      data2 = await res2.json();
                    } catch (e) {
                      append('Start(JSON parallel) parse error: ' + e.message, 'err');
                      statusEl.textContent = 'Start failed (parse)';
                      return;
                    }
                    append('Start payload: ' + JSON.stringify({ success: data2.success, correlation_id: data2.correlation_id, hasState: !!data2.state }), 'dim');
                    if (data2.debug) {
                      append('LLM(JSON) model: ' + data2.debug.model, 'dim');
                      if (data2.debug.reason) append('LLM(JSON) reason: ' + data2.debug.reason, 'dim');
                    }
                    if (!res2.ok || !data2.success) {
                      const errMsg = data2.error || data2.message || `HTTP ${res2.status}`;
                      append('Start failed: ' + errMsg, 'err');
                      if (data2.raw) {
                        const rawStr = typeof data2.raw === 'string' ? data2.raw : JSON.stringify(data2.raw);
                        append('Raw: ' + rawStr.substring(0, 400) + (rawStr.length > 400 ? '...' : ''), 'err');
                      }
                      statusEl.textContent = 'Start failed';
                      return;
                    }
                    if (data2.success && data2.state) {
                      sessionId = data2.session_id || sessionFromStream;
                      append('Session: ' + sessionId, 'dim');
                      if (data2.message) append(data2.message, '');
                      lastState = data2.state;
                      renderState(lastState);
                      append('Type help for available commands.', 'dim');
                      statusEl.textContent = 'Ready';
                      cmdEl.disabled = false; sendEl.disabled = false; cmdEl.focus();
                      if (pendingCommand) { const c = pendingCommand; pendingCommand = null; append(c, 'user'); sendCommand(c); }
                    }
                  })().catch(e => { append('Start(JSON parallel) error: ' + e.message, 'err'); statusEl.textContent = 'Start failed'; });
                }
              }
              if (msg.type === 'message') { append(msg.content); }
              if (msg.type === 'error') { append('Stream error: ' + msg.message, 'err'); }
            } catch {}
          }
        }
      } catch (e) {
        append('Stream failed: ' + e.message, 'err');
      }

      // 2) Fetch JSON state (fallback if we did not already start it)
      if (!startedJsonFetch) {
        let res;
        try {
          append('POST /v3/api/console/start', 'dim');
          const t0 = performance.now();
          const startBody = sessionFromStream ? { session_id: sessionFromStream } : {};
          res = await fetch('/v3/api/console/start', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(startBody) });
          const t1 = performance.now();
          append(`Response ${res.status} in ${Math.round(t1 - t0)}ms`, 'dim');
        } catch (e) {
          append('Network error starting session: ' + e.message, 'err');
          statusEl.textContent = 'Start failed: ' + e.message + ' (click Restart)';
          return;
        }
        let data;
        try {
          data = await res.json();
        } catch (e) {
          append('Failed to parse JSON from start: ' + e.message, 'err');
          return;
        }
        append('Start payload: ' + JSON.stringify({ success: data.success, correlation_id: data.correlation_id, hasState: !!data.state }), 'dim');
        if (data.debug) {
          append('LLM(JSON) model: ' + data.debug.model, 'dim');
          if (data.debug.reason) append('LLM(JSON) reason: ' + data.debug.reason, 'dim');
        }
        if (!data.success) {
          append('Failed to start: ' + (data.error || data.message || 'unknown'), 'err');
          if (data.raw) append('Raw: ' + (typeof data.raw === 'string' ? data.raw.substring(0,200) : JSON.stringify(data.raw).substring(0,200)) + '...', 'err');
          return;
        }
        sessionId = data.session_id || sessionFromStream;
        append('Session: ' + sessionId, 'dim');
        if (data.message) append(data.message);
        lastState = data.state;
        renderState(lastState);
        append('Type help for available commands.', 'dim');
        statusEl.textContent = 'Ready';
        cmdEl.disabled = false; sendEl.disabled = false; cmdEl.focus();
        if (pendingCommand) { const c = pendingCommand; pendingCommand = null; append(c, 'user'); sendCommand(c); }
      } else if (startJsonPromise) {
        // If we already started it, make sure we wait for completion to update UI if needed
        try { await startJsonPromise; } catch {}
      }
    }

    let isCommandInFlight = false;

    async function sendCommand(text) {
      if (!sessionId) {
        pendingCommand = text;
        append('Waiting for session to start before sending command...', 'dim');
        return;
      }
      if (isCommandInFlight) {
        pendingCommand = text;
        append('Command in progress; queuing your input...', 'dim');
        return;
      }
      isCommandInFlight = true;
      cmdEl.disabled = true; sendEl.disabled = true; statusEl.textContent = 'Sending command...';

      // 1) Stream narrative for the command
      try {
        append('POST /v3/api/console/command-stream', 'dim');
        const resp = await fetch('/v3/api/console/command-stream', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ session_id: sessionId, command: text }) });
        const reader = resp.body.getReader();
        const decoder = new TextDecoder();
        let buf = '';
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          buf += decoder.decode(value, { stream: true });
          const parts = buf.split('\n\n');
          buf = parts.pop() || '';
          for (const p of parts) {
            if (!p.startsWith('data:')) continue;
            const json = p.slice(5).trim();
            try {
              const msg = JSON.parse(json);
              if (msg.type === 'message') append(msg.content, undefined, msg.ts);
              if (msg.type === 'error') append('Stream error: ' + msg.message, 'err', msg.ts);
            } catch {}
          }
        }
      } catch (e) {
        append('Stream failed: ' + e.message, 'err');
      }

      // 2) Fetch JSON update for state
      append(`POST /v3/api/console/command ${JSON.stringify({ session_id: sessionId, command: text })}`, 'dim');
      let res;
      try {
        const t0 = performance.now();
        res = await fetch('/v3/api/console/command', {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ session_id: sessionId, command: text })
        });
        const t1 = performance.now();
        append(`Command response ${res.status} in ${Math.round(t1 - t0)}ms`, 'dim');
      } catch (e) {
        append('Network error sending command: ' + e.message, 'err');
        isCommandInFlight = false;
        statusEl.textContent = 'Ready';
        cmdEl.disabled = false; sendEl.disabled = false; cmdEl.focus();
        return;
      }
      let data;
      try { data = await res.json(); } catch (e) {
        append('Failed to parse JSON from command: ' + e.message, 'err');
        isCommandInFlight = false;
        statusEl.textContent = 'Ready';
        cmdEl.disabled = false; sendEl.disabled = false; cmdEl.focus();
        return;
      }
      append('Command payload: ' + JSON.stringify({ success: data.success, correlation_id: data.correlation_id, hasState: !!data.state }), 'dim');
      if (!data.success) {
        append((data.message || data.error || 'Error') + (data.correlation_id ? ' ['+data.correlation_id+']' : ''), 'err');
        isCommandInFlight = false;
        statusEl.textContent = 'Ready';
        cmdEl.disabled = false; sendEl.disabled = false; cmdEl.focus();
        return;
      }
      if (data.message) append(data.message, '');
      lastState = data.state || lastState;
      renderState(lastState);

      isCommandInFlight = false;
      statusEl.textContent = 'Ready';
      cmdEl.disabled = false; sendEl.disabled = false; cmdEl.focus();
      if (pendingCommand) { const c = pendingCommand; pendingCommand = null; append(c, 'user'); sendCommand(c); }
    }

    sendEl.addEventListener('click', () => {
      const text = cmdEl.value.trim();
      if (!text) return;
      if (!sessionId) {
        pendingCommand = text;
        append('Waiting for session to start before sending command...', 'dim');
        cmdEl.value = '';
        return;
      }
      if (isCommandInFlight) {
        pendingCommand = text;
        append('Command in progress; queuing your input...', 'dim');
        cmdEl.value = '';
        return;
      }
      append(text, 'user');
      cmdEl.value = '';
      sendCommand(text);
    });

    restartEl.addEventListener('click', () => {
      sessionId = null; lastState = null; pendingCommand = null;
      append('Restarting session...', 'warning');
      startSession();
    });

    cmdEl.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') sendEl.click();
    });

    // Quick nano status ping on load
    (async () => {
      const t0 = performance.now();
      append('STATUS: sending nano warm check...', 'dim');
      try {
        const res = await fetch('/v3/api/console/status');
        const t1 = performance.now();
        const data = await res.json();
        if (res.ok && data.ok) {
          append(`STATUS: send=${new Date().toISOString()} recv=${new Date().toISOString()} elapsed_UI=${Math.round(t1 - t0)}ms server=${data.elapsed_ms}ms model=${data.model}`, 'dim');
        } else {
          append(`STATUS: failed server=${data.elapsed_ms}ms error=${data.error || res.status}`, 'err');
        }
      } catch (e) {
        const t1 = performance.now();
        append(`STATUS: failed after ${Math.round(t1 - t0)}ms: ${e.message}`, 'err');
      }
      startSession();
    })();
  </script>
</body>
</html>

